__device__ void _REGISTER_TID(unsigned int NO,        // NO 表示当前实例是这类事务实例的第 NO 个
                              unsigned int OP,        // OP 表示当前操作是本示例中的第 OP 个
                              unsigned int query_cnt, // query_cnt表示当前事务个数, 如 NEWORDER_CNT, PAYMENT_CNT 等
                              unsigned int *TID,
                              unsigned int log_loc_up,    // Loc 表示当前访问的数据在第几行
                              unsigned int log_loc_down,  // Loc 表示当前访问的数据在第几行
                              unsigned int Columns,       // Columns 表示当前访问的数据在第几列, 详细描述见下面对 Column 的操作, 暂时使用的锁粒度为数据行
                              unsigned int *LOG_LOC_UP,   // LOG_Loc_up LOG 的上32位，
                              unsigned int *LOG_LOC_DOWN, //
                              unsigned int *LOG_TID)      // LOG_TID 记录 TID 信息, 32 位 TID, 前 12 位是 BATCH_ID, 后 20 位是 ID

{
    unsigned int index = NO * query_cnt + OP;
    // unsigned int log_loc = (((TABLE_ID << 32) + Loc) << 24) + isWrite;
    LOG_LOC_UP[index] = log_loc_up;
    LOG_LOC_DOWN[index] = log_loc_down;
    LOG_TID[index] = TID[NO];
    //
    // printf("REGISTER NO = %d, OP = %d, TID = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, OP, LOG_TID[index], LOG_LOC_UP[index], LOG_LOC_DOWN[index]);

    // printf("REGISTER index = %d, TID = 0x%08x, TABLE_ID = %d, Loc = 0x%08x, Columns = %d, isWrite = %d\n", index, TID, TABLE_ID, Loc, Columns, isWrite);
    // printf("REGISTER log_loc = %llx, index = %d\n", (((TABLE_ID << 32) + Loc) << 24) + isWrite, index);
    // unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
    // printf("REGISTER threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x);
}
__global__ void _READ(unsigned int NO,             // NO 表示当前实例是这类事务实例的第 NO 个
                      unsigned int OP,             // OP 表示当前操作是本示例中的第 OP 个
                      unsigned int query_cnt,      // query_cnt表示当前事务个数, 如 NEWORDER_CNT, PAYMENT_CNT 等
                      unsigned int column_size,    // column_size 表示当前访问的数据表快照有多少行
                      unsigned int Loc,            // Loc 表示当前访问的数据在第几行
                      unsigned int Columns,        // Columns 表示当前访问的数据在第几列, 详细描述见下面对 Column 的操作
                      unsigned int *set_local_set, // set_local_set 是 SET 中的 local_set, 以 SoA 的形式实现
                      unsigned int *table,         // table 是当前访问的数据表快照
                      unsigned int *index,         // index 是当前访问数据表快照的索引, 预留了接口但并未使用
                      LOG *log)
{
    unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x; // thID 表示当前线程的 threadIdx.x
    // unsigned int column = 1 << thID;     // column 表示对 1 移位计算, 移位数量为当前线程ID, 如线程ID为 4, 则此时 column 此时为 0b10000
    // column = (Columns & column) && thID; // column 此时表示 Columns 与 对 1 移位计算的与运算结果, 如果 column 此时不为 0, 表示第4列是要访问的数据
    // 如 column 此时为 0, 表示第4列不是要访问的数据
    // unsigned int local_set_loc = (NO * query_cnt + OP) * 32 + thID; // "OP * query_cnt" 表示原有设计中 set 在第几行, 列存储格式, 不同实例的相同操作放在一起
    // "OP * query_cnt + NO" 表示原有设计中的 set
    // "(OP * query_cnt + NO) * 32" 表示 set_local_set 的位置
    unsigned int column = Loc * column_size + thID;                   // "Loc * column_size + column" 表示要访问的数据在表中的位置, 行存储格式
    set_local_set[(NO * query_cnt + OP) * 32 + thID] = table[column]; // 从数据表快照中读取数据
}
__global__ void _WRITE(unsigned int NO,             // NO 表示当前实例是这类事务实例的第 NO 个
                       unsigned int OP,             // OP 表示当前操作是本示例中的第 OP 个
                       unsigned int query_cnt,      // query_cnt表示当前事务个数, 如 NEWORDER_CNT, PAYMENT_CNT 等
                       unsigned int column_size,    // column_size 表示当前访问的数据表快照有多少行
                       unsigned int Loc,            // Loc 表示当前访问的数据在第几行
                       unsigned int Columns,        // Columns 表示当前访问的数据在第几列, 详细描述见下面对 Column 的操作
                       unsigned int *set_local_set, // set_local_set 是 SET 中的 local_set, 以 SoA 的形式实现
                       unsigned int *table,         // table 是当前访问的数据表快照
                       unsigned int *index,         // index 是当前访问数据表快照的索引, 预留了接口但并未使用
                       LOG *log)
{
    unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x; // thID 表示当前线程的 threadIdx.x
    // unsigned int column = 1 << thID;     // column 表示对 1 移位计算, 移位数量为当前线程ID, 如线程ID为 4, 则此时 column 此时为 0b10000
    // column = (Columns & column) && thID; // column 此时表示 Columns 与 对 1 移位计算的与运算结果, 如果 column 此时为 1, 表示第4列是要访问的数据
    // 如 column 此时为 0, 表示第4列不是要访问的数据
    // unsigned int local_set_loc = (NO * query_cnt + OP) * 32 + thID; // "OP * query_cnt" 表示原有设计中 set 在第几行, 列存储格式, 不同实例的相同操作放在一起
    // "OP * query_cnt + NO" 表示原有设计中的 set
    // "(OP * query_cnt + NO) * 32" 表示 set_local_set 的位置
    unsigned int column = Loc * column_size + thID;                   // "Loc * column_size + column" 表示要访问的数据在表中的位置, 行存储格式
    set_local_set[(NO * query_cnt + OP) * 32 + thID] = table[column]; // 从数据表快照中读取数据, 并修改到本地写集
                                                                      // printf("index = %d, query_cnt = %d, column_size = %d, Loc = %d, Columns = %d\n", NO * query_cnt + OP, query_cnt, column_size, Loc, Columns);
}

__global__ void op_0(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // select warehouse
        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("NO 0x%08x\n", NO);
            unsigned int WID = neworder->query[NO].W_ID;
            unsigned int Loc = WID;
            unsigned int log_loc_up = (WAREHOUSE_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + READ_TYPE;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 0] = Loc;
            // unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("N op_0 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_0 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);
            _READ<<<1, WAREHOUSE_COLUMN, 0, cudaStreamPerThread>>>(NO, 0, NEWORDER_OP_CNT, WAREHOUSE_COLUMN, Loc, NEWORDER_COLUMN_0, neworder->set_local_set, snapshot->warehouse_snapshot, index->index, log);
            _REGISTER_TID(NO, 0, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_0, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 0] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 0] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 0] = neworder->TID[NO];
        }
    }

    __global__ void op_1(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // select district

        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            unsigned int WID = neworder->query[NO].W_ID;
            unsigned int DID = neworder->query[NO].D_ID;
            unsigned int Loc = WID * 10 + DID;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 1] = Loc;
            unsigned int log_loc_up = (DISTRICT_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + READ_TYPE;
            // unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("N op_1 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_1 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);
            _READ<<<1, DISTRICT_COLUMN, 0, cudaStreamPerThread>>>(NO, 1, NEWORDER_OP_CNT, DISTRICT_COLUMN, Loc, NEWORDER_COLUMN_1, neworder->set_local_set, snapshot->district_snapshot, index->index, log);
            _REGISTER_TID(NO, 1, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_1, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 1] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 1] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 1] = neworder->TID[NO];
        }
    }

    __global__ void op_2(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // select customer

        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            unsigned int WID = neworder->query[NO].W_ID;
            unsigned int DID = neworder->query[NO].D_ID;
            unsigned int CID = neworder->query[NO].C_ID;
            unsigned int Loc = WID * 30000 + DID * 3000 + CID;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 2] = Loc;
            unsigned int log_loc_up = (CUSTOMER_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + READ_TYPE;
            // unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("N op_2 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_2 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);
            _READ<<<1, CUSTOMER_COLUMN, 0, cudaStreamPerThread>>>(NO, 2, NEWORDER_OP_CNT, CUSTOMER_COLUMN, Loc, NEWORDER_COLUMN_2, neworder->set_local_set, snapshot->customer_snapshot, index->index, log);
            _REGISTER_TID(NO, 2, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_2, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 2] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 2] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 2] = neworder->TID[NO];
        }
    }

    __global__ void op_3(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // insert neworder

        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            unsigned int WID = neworder->query[NO].W_ID;
            unsigned int NOID = neworder->query[NO].N_O_ID;
            unsigned int Loc = WID * 30000 + NOID;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 3] = Loc;
            unsigned int log_loc_up = (NEWORDER_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            // unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("N op_3 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_3 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);
            _WRITE<<<1, NEWORDER_COLUMN, 0, cudaStreamPerThread>>>(NO, 3, NEWORDER_OP_CNT, NEWORDER_COLUMN, Loc, NEWORDER_COLUMN_3, neworder->set_local_set, snapshot->neworder_snapshot, index->index, log);
            _REGISTER_TID(NO, 3, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_3, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 3] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 3] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 3] = neworder->TID[NO];
        }
    }

    __global__ void op_4(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // insert order
        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            unsigned int WID = neworder->query[NO].W_ID;
            unsigned int OID = neworder->query[NO].O_ID;
            unsigned int Loc = WID * 30000 + OID;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 4] = Loc;
            unsigned int log_loc_up = (ORDER_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            // unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("N op_4 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_4 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);
            _WRITE<<<1, ORDER_COLUMN, 0, cudaStreamPerThread>>>(NO, 4, NEWORDER_OP_CNT, ORDER_COLUMN, Loc, NEWORDER_COLUMN_4, neworder->set_local_set, snapshot->order_snapshot, index->index, log);
            _REGISTER_TID(NO, 4, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_4, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 4] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 4] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 4] = neworder->TID[NO];
        }
    }

    __global__ void op_5(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // select item
        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("N op_5 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_5 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);
            unsigned int IID = neworder->query[NO].INFO[thID].OL_I_ID;
            unsigned int Loc = IID;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 5 + thID] = Loc;
            unsigned int log_loc_up = (ITEM_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + READ_TYPE;
            // printf("N op_5 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_5 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);

            _READ<<<1, ITEM_COLUMN, 0, cudaStreamPerThread>>>(NO, 5 + thID, NEWORDER_OP_CNT, ITEM_COLUMN, Loc, NEWORDER_COLUMN_5, neworder->set_local_set, snapshot->item_snapshot, index->index, log);
            _REGISTER_TID(NO, 5 + thID, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_5, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 5 + thID] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 5 + thID] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 5 + thID] = neworder->TID[NO];
        }
    }

    __global__ void op_6(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // update stock

        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            unsigned int SWID = neworder->query[NO].INFO[thID].OL_SUPPLY_W_ID;
            unsigned int IID = neworder->query[NO].INFO[thID].OL_I_ID;
            unsigned int Loc = SWID * 100000 + IID;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 20 + thID] = Loc;
            unsigned int log_loc_up = (STOCK_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            // printf("N op_6 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_6 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);

            _WRITE<<<1, STOCK_COLUMN, 0, cudaStreamPerThread>>>(NO, 20 + thID, NEWORDER_OP_CNT, STOCK_COLUMN, Loc, NEWORDER_COLUMN_6, neworder->set_local_set, snapshot->stock_snapshot, index->index, log);
            _REGISTER_TID(NO, 20 + thID, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_6, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 20 + thID] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 20 + thID] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 20 + thID] = neworder->TID[NO];
        }
    }

    __global__ void op_7(unsigned int NO,
                         NEWORDER_SET *neworder,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // insert orderline
        if (NO < NEWORDER_CNT)
        {
            unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            unsigned int WID = neworder->query[NO].W_ID;
            unsigned int OOLID = neworder->query[NO].O_OL_ID;
            unsigned int Loc = WID * 450000 + OOLID + thID;
            neworder->set_Loc[NEWORDER_OP_CNT * NO + 35 + thID] = Loc;
            unsigned int log_loc_up = (ORDERLINE_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            // printf("N op_7 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("N op_7 NO %d, Loc %d, Columns 0x%08x\n", NO, Loc, Columns);
            // printf("N op_7 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, neworder->TID[NO], Loc, log_loc_up, log_loc_down);
            _WRITE<<<1, ORDERLINE_COLUMN, 0, cudaStreamPerThread>>>(NO, 35 + thID, NEWORDER_OP_CNT, ORDERLINE_COLUMN, Loc, NEWORDER_COLUMN_7, neworder->set_local_set, snapshot->orderline_snapshot, index->index, log);
            _REGISTER_TID(NO, 35 + thID, NEWORDER_OP_CNT, neworder->TID, log_loc_up, log_loc_down, NEWORDER_COLUMN_7, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            // log->LOG_LOC_N_UP[NEWORDER_OP_CNT * NO + 35 + thID] = log_loc_up;
            // log->LOG_LOC_N_DOWN[NEWORDER_OP_CNT * NO + 35 + thID] = log_loc_down;
            // log->LOG_TID_N[NEWORDER_OP_CNT * NO + 35 + thID] = neworder->TID[NO];
        }
    }



    __global__ void op_0(unsigned int NO,
                         PAYMENT_SET *payment,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // select warehouse
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < PAYMENT_CNT)
        {
            unsigned int WID = payment->query[NO].W_ID;
            unsigned int Loc = WID;
            payment->set_Loc[PAYMENT_OP_CNT * NO + 0] = Loc;
            unsigned int log_loc_up = (WAREHOUSE_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + READ_TYPE;
            // unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
            // printf("P op_0 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("P op_0 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, payment->TID[NO], Loc, log_loc_up, log_loc_down);
            _READ<<<1, WAREHOUSE_COLUMN, 0, cudaStreamPerThread>>>(NO, 0, PAYMENT_OP_CNT, WAREHOUSE_COLUMN, Loc, PAYMENT_COLUMN_0, payment->set_local_set, snapshot->warehouse_snapshot, index->index, log);
            _REGISTER_TID(NO, 0, PAYMENT_OP_CNT, payment->TID, log_loc_up, log_loc_down, PAYMENT_COLUMN_0, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            // log->LOG_LOC_P_UP[PAYMENT_OP_CNT * NO + 0] = log_loc_up;
            // log->LOG_LOC_P_DOWN[PAYMENT_OP_CNT * NO + 0] = log_loc_down;
            // log->LOG_TID_P[PAYMENT_OP_CNT * NO + 0] = payment->TID[NO];
        }
    }

    __global__ void op_1(unsigned int NO,
                         PAYMENT_SET *payment,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // update warehouse
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < PAYMENT_CNT)
        {
            unsigned int WID = payment->query[NO].W_ID;
            unsigned int Loc = WID;
            payment->set_Loc[PAYMENT_OP_CNT * NO + 1] = Loc;
            unsigned int log_loc_up = (WAREHOUSE_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            // printf("P op_1 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("P op_1 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, payment->TID[NO], Loc, log_loc_up, log_loc_down);
            _WRITE<<<1, WAREHOUSE_COLUMN, 0, cudaStreamPerThread>>>(NO, 1, PAYMENT_OP_CNT, WAREHOUSE_COLUMN, Loc, PAYMENT_COLUMN_1, payment->set_local_set, snapshot->warehouse_snapshot, index->index, log);
            _REGISTER_TID(NO, 1, PAYMENT_OP_CNT, payment->TID, log_loc_up, log_loc_down, PAYMENT_COLUMN_1, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            // log->LOG_LOC_P_UP[PAYMENT_OP_CNT * NO + 1] = log_loc_up;
            // log->LOG_LOC_P_DOWN[PAYMENT_OP_CNT * NO + 1] = log_loc_down;
            // log->LOG_TID_P[PAYMENT_OP_CNT * NO + 1] = payment->TID[NO];
        }
    }

    __global__ void op_2(unsigned int NO,
                         PAYMENT_SET *payment,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // select district
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < PAYMENT_CNT)
        {
            unsigned int WID = payment->query[NO].W_ID;
            unsigned int DID = payment->query[NO].D_ID;
            unsigned int Loc = WID * 10 + DID;
            payment->set_Loc[PAYMENT_OP_CNT * NO + 2] = Loc;
            unsigned int log_loc_up = (DISTRICT_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + READ_TYPE;
            // printf("P op_2 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("P op_2 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, payment->TID[NO], Loc, log_loc_up, log_loc_down);
            _READ<<<1, DISTRICT_COLUMN, 0, cudaStreamPerThread>>>(NO, 2, PAYMENT_OP_CNT, DISTRICT_COLUMN, Loc, PAYMENT_COLUMN_2, payment->set_local_set, snapshot->district_snapshot, index->index, log);
            _REGISTER_TID(NO, 2, PAYMENT_OP_CNT, payment->TID, log_loc_up, log_loc_down, PAYMENT_COLUMN_2, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            // log->LOG_LOC_P_UP[PAYMENT_OP_CNT * NO + 2] = log_loc_up;
            // log->LOG_LOC_P_DOWN[PAYMENT_OP_CNT * NO + 2] = log_loc_down;
            // log->LOG_TID_P[PAYMENT_OP_CNT * NO + 2] = payment->TID[NO];
        }
    }

    __global__ void op_3(unsigned int NO,
                         PAYMENT_SET *payment,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // update district
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < PAYMENT_CNT)
        {
            unsigned int WID = payment->query[NO].W_ID;
            unsigned int DID = payment->query[NO].D_ID;
            unsigned int Loc = WID * 10 + DID;
            payment->set_Loc[PAYMENT_OP_CNT * NO + 3] = Loc;
            unsigned int log_loc_up = (DISTRICT_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            // printf("P op_3 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("P op_3 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, payment->TID[NO], Loc, log_loc_up, log_loc_down);
            _WRITE<<<1, DISTRICT_COLUMN, 0, cudaStreamPerThread>>>(NO, 3, PAYMENT_OP_CNT, DISTRICT_COLUMN, Loc, PAYMENT_COLUMN_3, payment->set_local_set, snapshot->district_snapshot, index->index, log);
            _REGISTER_TID(NO, 3, PAYMENT_OP_CNT, payment->TID, log_loc_up, log_loc_down, PAYMENT_COLUMN_3, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            // log->LOG_LOC_P_UP[PAYMENT_OP_CNT * NO + 3] = log_loc_up;
            // log->LOG_LOC_P_DOWN[PAYMENT_OP_CNT * NO + 3] = log_loc_down;
            // log->LOG_TID_P[PAYMENT_OP_CNT * NO + 3] = payment->TID[NO];
        }
    }

    __global__ void op_4(unsigned int NO,
                         PAYMENT_SET *payment,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // select customer
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < PAYMENT_CNT)
        {
            unsigned int CWID = payment->query[NO].C_W_ID;
            unsigned int CDID = payment->query[NO].C_D_ID;
            // if (payment->query[NO].isName)
            // {
            //     unsigned int C_LAST = payment->query[NO].C_LAST;
            //     unsigned int C_LAST_ID = C_LAST & 0xff;
            //     C_LAST = C_LAST >> 8;
            //     unsigned int distance = 0;
            //     _FIND_CID_INDEX<<<1, 32, 0,cudaStreamPerThread  >>>(C_LAST, CWID * 30000 + CDID * 3000, index->customer_name_index + CWID * 30000 + CDID * 3000, 3000, C_LAST_ID, &payment->query[NO].C_ID, snapshot->customer_snapshot);
            //     distance = payment->DISTANCE[NO] + CWID * 30000 + CDID * 3000;
            //     unsigned int CID = snapshot->customer_snapshot[distance * CUSTOMER_COLUMN + 0];
            //     payment->query[NO].C_ID = CID;
            //     printf("C_LAST = 0x%08x\n", C_LAST);
            //     // unsigned int *PTR = thrust::find(thrust::device, index->customer_name_index + CWID * 30000 + CDID * 3000, index->customer_name_index + CWID * 30000 + CDID * 3000 + 3000, C_LAST);
            //     // unsigned int distance = PTR - (index->customer_name_index + CWID * 30000 + CDID * 3000);
            //     // unsigned int CID = snapshot->customer_snapshot[distance * CUSTOMER_COLUMN + 0];
            // }
            unsigned int CID = payment->query[NO].C_ID;
            // printf("CID %d\n", CID);
            unsigned int Loc = CWID * 30000 + CDID * 3000 + CID;
            payment->set_Loc[PAYMENT_OP_CNT * NO + 4] = Loc;
            unsigned int log_loc_up = (CUSTOMER_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + READ_TYPE;
            // printf("P op_4 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("P op_4 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, payment->TID[NO], Loc, log_loc_up, log_loc_down);
            _READ<<<1, CUSTOMER_COLUMN, 0, cudaStreamPerThread>>>(NO, 4, PAYMENT_OP_CNT, CUSTOMER_COLUMN, Loc, PAYMENT_COLUMN_4, payment->set_local_set, snapshot->customer_snapshot, index->index, log);
            _REGISTER_TID(NO, 4, PAYMENT_OP_CNT, payment->TID, log_loc_up, log_loc_down, PAYMENT_COLUMN_4, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            // log->LOG_LOC_P_UP[PAYMENT_OP_CNT * NO + 4] = log_loc_up;
            // log->LOG_LOC_P_DOWN[PAYMENT_OP_CNT * NO + 4] = log_loc_down;
            // log->LOG_TID_P[PAYMENT_OP_CNT * NO + 4] = payment->TID[NO];
        }
    }

    __global__ void op_5(unsigned int NO,
                         PAYMENT_SET *payment,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // update customer
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < PAYMENT_CNT)
        {
            unsigned int CWID = payment->query[NO].C_W_ID;
            unsigned int CDID = payment->query[NO].C_D_ID;
            // if (payment->query[NO].isName)
            // {
            //     // printf("isName = %d\n", payment->query[NO].isName);
            //     unsigned int C_LAST = payment->query[NO].C_LAST;
            //     unsigned int C_LAST_ID = C_LAST & 0xff;
            //     C_LAST = C_LAST >> 8;
            //     unsigned int distance = 0;
            //     _FIND_CID_INDEX<<<1, 32, 0,cudaStreamPerThread  >>>(C_LAST, CWID * 30000 + CDID * 3000, index->customer_name_index + CWID * 30000 + CDID * 3000, 3000, C_LAST_ID, &payment->query[NO].C_ID, snapshot->customer_snapshot);
            //     distance = payment->DISTANCE[NO] + CWID * 30000 + CDID * 3000;
            //     unsigned int CID = snapshot->customer_snapshot[distance * CUSTOMER_COLUMN + 0];
            //     payment->query[NO].C_ID = CID;
            //     printf("C_LAST = 0x%08x\n", C_LAST);
            //     // unsigned int *PTR = thrust::find(thrust::device, index->customer_name_index + CWID * 30000 + CDID * 3000, index->customer_name_index + CWID * 30000 + CDID * 3000 + 3000, C_LAST);
            //     // unsigned int distance = PTR - (index->customer_name_index + CWID * 30000 + CDID * 3000);
            //     // unsigned int CID = snapshot->customer_snapshot[distance * CUSTOMER_COLUMN + 0];
            // }
            unsigned int CID = payment->query[NO].C_ID;
            unsigned int Loc = CWID * 30000 + CDID * 3000 + CID;
            unsigned int log_loc_up = (CUSTOMER_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            payment->set_Loc[PAYMENT_OP_CNT * NO + 5] = Loc;
            // printf("P op_5 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("P op_5 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, payment->TID[NO], Loc, log_loc_up, log_loc_down);
            _WRITE<<<1, CUSTOMER_COLUMN, 0, cudaStreamPerThread>>>(NO, 5, PAYMENT_OP_CNT, CUSTOMER_COLUMN, Loc, PAYMENT_COLUMN_5, payment->set_local_set, snapshot->customer_snapshot, index->index, log);
            _REGISTER_TID(NO, 5, PAYMENT_OP_CNT, payment->TID, log_loc_up, log_loc_down, PAYMENT_COLUMN_5, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            // log->LOG_LOC_P_UP[PAYMENT_OP_CNT * NO + 5] = log_loc_up;
            // log->LOG_LOC_P_DOWN[PAYMENT_OP_CNT * NO + 5] = log_loc_down;
            // log->LOG_TID_P[PAYMENT_OP_CNT * NO + 5] = payment->TID[NO];
        }
    }

    __global__ void op_6(unsigned int NO,
                         PAYMENT_SET *payment,
                         LOG *log,
                         SNAPSHOT *snapshot,
                         INDEX *index)
    { // insert history
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < PAYMENT_CNT)
        {
            unsigned int WID = payment->query[NO].W_ID;
            unsigned int HID = payment->query[NO].H_ID;
            unsigned int Loc = WID * 30000 + HID;
            unsigned int log_loc_up = (HISTORY_ID << 24) + (Loc >> 8);
            unsigned int log_loc_down = (Loc << 24) + WRITE_TYPE;
            payment->set_Loc[PAYMENT_OP_CNT * NO + 6] = Loc;
            // printf("P op_6 threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
            // printf("P op_6 NO = %d, TID = 0x%08x, Loc = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", NO, payment->TID[NO], Loc, log_loc_up, log_loc_down);
            _WRITE<<<1, HISTORY_COLUMN, 0, cudaStreamPerThread>>>(NO, 6, PAYMENT_OP_CNT, HISTORY_COLUMN, Loc, PAYMENT_COLUMN_6, payment->set_local_set, snapshot->history_snapshot, index->index, log);
            _REGISTER_TID(NO, 6, PAYMENT_OP_CNT, payment->TID, log_loc_up, log_loc_down, PAYMENT_COLUMN_6, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            // log->LOG_LOC_P_UP[PAYMENT_OP_CNT * NO + 6] = log_loc_up;
            // log->LOG_LOC_P_DOWN[PAYMENT_OP_CNT * NO + 6] = log_loc_down;
            // log->LOG_TID_P[PAYMENT_OP_CNT * NO + 6] = payment->TID[NO];
        }
    }











    __global__ void check_0(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // select warehouse
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 0];
            // _READ_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 0, TID, WAREHOUSE_ID, NEWORDER_OP_CNT, Loc, neworder->raw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (WAREHOUSE_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 0, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->raw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_1(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // select district
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 1];
            // _READ_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 1, TID, DISTRICT_ID, NEWORDER_OP_CNT, Loc, neworder->raw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (DISTRICT_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 1, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->raw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_2(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // select customer
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 2];
            // _READ_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 2, TID, CUSTOMER_ID, NEWORDER_OP_CNT, Loc, neworder->raw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (CUSTOMER_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 2, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->raw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_3(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // insert neworder
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 3];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 3, TID, NEWORDER_ID, NEWORDER_OP_CNT, Loc, neworder->war, neworder->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (NEWORDER_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 3, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->war, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 3, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->waw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_4(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // insert order
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 4];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 4, TID, ORDER_ID, NEWORDER_OP_CNT, Loc, neworder->war, neworder->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (ORDER_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 4, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->war, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 4, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->waw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_5(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // select item
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 5 + thID];
            // _READ_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 5 + thID, TID, ITEM_ID, NEWORDER_OP_CNT, Loc, neworder->raw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (ITEM_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 5 + thID, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->raw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_6(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update stock
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 20 + thID];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 20 + thID, TID, STOCK_ID, NEWORDER_OP_CNT, Loc, neworder->war, neworder->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (STOCK_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 20 + thID, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->war, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 20 + thID, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->waw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_7(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // insert orderline
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < NEWORDER_CNT)
        {
            unsigned int TID = neworder->TID[NO];
            unsigned int Loc = neworder->set_Loc[NEWORDER_OP_CNT * NO + 35 + thID];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 35 + thID, TID, ORDERLINE_ID, NEWORDER_OP_CNT, Loc, neworder->war, neworder->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (ORDERLINE_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 35 + thID, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->war, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 35 + thID, TID, NEWORDER_OP_CNT, log_up, log_down, neworder->waw, log->LOG_LOC_N_UP, log->LOG_LOC_N_DOWN, log->LOG_TID_N);
        }
    }

    __global__ void check_op(unsigned int NO,
                             NEWORDER_SET *neworder,
                             LOG *log,
                             SNAPSHOT *snapshot,
                             INDEX *index)
    {
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        // printf("check thID = %d\n", thID);
        unsigned int O_OL_CNT = neworder->query[thID].O_OL_CNT;
        if (thID == 0)
            check_0<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 1)
            check_1<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 2)
            check_2<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 3)
            check_3<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 4)
            check_4<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 5)
            check_5<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 6)
            check_6<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 7)
            check_7<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
    }

    __global__ void check(unsigned int NO,
                          NEWORDER_SET *neworder,
                          LOG *log,
                          SNAPSHOT *snapshot,
                          INDEX *index)
    {
        // check_op<<<NEWORDER_TYPE_CNT, 1, 0,cudaStreamPerThread  >>>(NO, neworder, log, snapshot, index);
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;

        unsigned int O_OL_CNT = neworder->query[thID].O_OL_CNT;
        if (thID == 0)
            check_0<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 1)
            check_1<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 2)
            check_2<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 3)
            check_3<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 4)
            check_4<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 5)
            check_5<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 6)
            check_6<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 7)
            check_7<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
    }

    __global__ void check_0(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // select warehouse
        if (NO < PAYMENT_CNT)
        {
            unsigned int TID = payment->TID[NO];
            unsigned int Loc = payment->set_Loc[PAYMENT_OP_CNT * NO + 0];
            // _READ_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 0, TID, WAREHOUSE_ID, PAYMENT_OP_CNT, Loc, payment->raw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (WAREHOUSE_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 0, TID, PAYMENT_OP_CNT, log_up, log_down, payment->raw, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
        }
    }

    __global__ void check_1(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update warehouse
        if (NO < PAYMENT_CNT)
        {
            unsigned int TID = payment->TID[NO];
            unsigned int Loc = payment->set_Loc[PAYMENT_OP_CNT * NO + 1];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 1, TID, WAREHOUSE_ID, PAYMENT_OP_CNT, Loc, payment->war, payment->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (WAREHOUSE_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 1, TID, PAYMENT_OP_CNT, log_up, log_down, payment->war, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 1, TID, PAYMENT_OP_CNT, log_up, log_down, payment->waw, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
        }
    }
    __global__ void check_2(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // select district
        if (NO < PAYMENT_CNT)
        {
            unsigned int TID = payment->TID[NO];
            unsigned int Loc = payment->set_Loc[PAYMENT_OP_CNT * NO + 2];
            // _READ_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 2, TID, DISTRICT_ID, PAYMENT_OP_CNT, Loc, payment->raw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (DISTRICT_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 2, TID, PAYMENT_OP_CNT, log_up, log_down, payment->raw, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
        }
    }

    __global__ void check_3(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update district
        if (NO < PAYMENT_CNT)
        {
            unsigned int TID = payment->TID[NO];
            unsigned int Loc = payment->set_Loc[PAYMENT_OP_CNT * NO + 3];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 3, TID, DISTRICT_ID, PAYMENT_OP_CNT, Loc, payment->war, payment->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (DISTRICT_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 3, TID, PAYMENT_OP_CNT, log_up, log_down, payment->war, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 3, TID, PAYMENT_OP_CNT, log_up, log_down, payment->waw, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
        }
    }

    __global__ void check_4(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // select customer
        if (NO < PAYMENT_CNT)
        {
            unsigned int TID = payment->TID[NO];
            unsigned int Loc = payment->set_Loc[PAYMENT_OP_CNT * NO + 4];
            // _READ_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 4, TID, CUSTOMER_ID, PAYMENT_OP_CNT, Loc, payment->raw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (CUSTOMER_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 4, TID, PAYMENT_OP_CNT, log_up, log_down, payment->raw, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
        }
    }

    __global__ void check_5(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update customer
        if (NO < PAYMENT_CNT)
        {
            unsigned int TID = payment->TID[NO];
            unsigned int Loc = payment->set_Loc[PAYMENT_OP_CNT * NO + 5];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 5, TID, CUSTOMER_ID, PAYMENT_OP_CNT, Loc, payment->war, payment->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (CUSTOMER_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 5, TID, PAYMENT_OP_CNT, log_up, log_down, payment->war, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 5, TID, PAYMENT_OP_CNT, log_up, log_down, payment->waw, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
        }
    }

    __global__ void check_6(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // insert history
        if (NO < PAYMENT_CNT)
        {
            unsigned int TID = payment->TID[NO];
            unsigned int Loc = payment->set_Loc[PAYMENT_OP_CNT * NO + 6];
            // _WRITE_CHECK<<<1, 1, 0,cudaStreamPerThread  >>>(NO, 6, TID, HISTORY_ID, PAYMENT_OP_CNT, Loc, payment->war, payment->waw, log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID);
            unsigned int log_up = (HISTORY_ID << 24) + (Loc >> 8);
            unsigned int log_down = (Loc << 24) + READ_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 6, TID, PAYMENT_OP_CNT, log_up, log_down, payment->war, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
            log_down = (Loc << 24) + WRITE_TYPE;
            _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamPerThread>>>(NO, 6, TID, PAYMENT_OP_CNT, log_up, log_down, payment->waw, log->LOG_LOC_P_UP, log->LOG_LOC_P_DOWN, log->LOG_TID_P);
        }
    }

    __global__ void check_op(unsigned int NO,
                             PAYMENT_SET *payment,
                             LOG *log,
                             SNAPSHOT *snapshot,
                             INDEX *index)
    {
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        // printf("check thID = %d\n", thID);
        if (thID == 0)
            check_0<<<PAYMENT_TYPE_CNT, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 1)
            check_1<<<PAYMENT_TYPE_CNT, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 2)
            check_2<<<PAYMENT_TYPE_CNT, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 3)
            check_3<<<PAYMENT_TYPE_CNT, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 4)
            check_4<<<PAYMENT_TYPE_CNT, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 5)
            check_5<<<PAYMENT_TYPE_CNT, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 6)
            check_6<<<PAYMENT_TYPE_CNT, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
    }



__global__ void op_wb_3(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // insert neworder
        if (NO < NEWORDER_CNT)
        {
            unsigned int raw = neworder->raw[NO];
            unsigned int war = neworder->war[NO];
            unsigned int waw = neworder->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = neworder->set_Loc[NO * NEWORDER_OP_CNT + 3];
                _WRITE_BACK<<<1, NEWORDER_COLUMN, 0, cudaStreamPerThread>>>(NO, 3, NEWORDER_OP_CNT, NEWORDER_COLUMN, Loc, NEWORDER_COLUMN_3, neworder->set_local_set, snapshot->neworder_snapshot, index->index, log);
            }
        }
    }

    __global__ void op_wb_4(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // insert order
        if (NO < NEWORDER_CNT)
        {
            unsigned int raw = neworder->raw[NO];
            unsigned int war = neworder->war[NO];
            unsigned int waw = neworder->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = neworder->set_Loc[NO * NEWORDER_OP_CNT + 3];
                _WRITE_BACK<<<1, ORDER_COLUMN, 0, cudaStreamPerThread>>>(NO, 4, NEWORDER_OP_CNT, ORDER_COLUMN, Loc, NEWORDER_COLUMN_4, neworder->set_local_set, snapshot->order_snapshot, index->index, log);
            }
        }
    }

    __global__ void op_wb_6(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update stock
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < NEWORDER_CNT)
        {
            unsigned int raw = neworder->raw[NO];
            unsigned int war = neworder->war[NO];
            unsigned int waw = neworder->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = neworder->set_Loc[NO * NEWORDER_OP_CNT + 3];
                _WRITE_BACK<<<1, STOCK_COLUMN, 0, cudaStreamPerThread>>>(NO, 20 + thID, NEWORDER_OP_CNT, STOCK_COLUMN, Loc, NEWORDER_COLUMN_6, neworder->set_local_set, snapshot->stock_snapshot, index->index, log);
            }
        }
    }

    __global__ void op_wb_7(unsigned int NO,
                            NEWORDER_SET *neworder,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // insert orderline
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (NO < NEWORDER_CNT)
        {
            unsigned int raw = neworder->raw[NO];
            unsigned int war = neworder->war[NO];
            unsigned int waw = neworder->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = neworder->set_Loc[NO * NEWORDER_OP_CNT + 3];
                _WRITE_BACK<<<1, ITEM_COLUMN, 0, cudaStreamPerThread>>>(NO, 35 + thID, NEWORDER_OP_CNT, ITEM_COLUMN, Loc, NEWORDER_COLUMN_7, neworder->set_local_set, snapshot->orderline_snapshot, index->index, log);
            }
        }
    }

    __global__ void write_back_op(unsigned int NO,
                                  NEWORDER_SET *neworder,
                                  LOG *log,
                                  SNAPSHOT *snapshot,
                                  INDEX *index)
    {
        // printf("check thID = %d\n", thID);
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        unsigned int O_OL_CNT = neworder->query[NO].O_OL_CNT;
        if (thID == 0)
            op_wb_3<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 1)
            op_wb_4<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 2)
            op_wb_6<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 3)
            op_wb_7<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
    }

        // write_back_op<<<NEWORDER_WB_TYPE_CNT, 1, 0,cudaStreamPerThread  >>>(NO, neworder, log, snapshot, index);
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        unsigned int O_OL_CNT = neworder->query[NO].O_OL_CNT;
        if (thID == 0)
            op_wb_3<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 1)
            op_wb_4<<<1, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 2)
            op_wb_6<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (thID == 3)
            op_wb_7<<<O_OL_CNT, 1, 0, cudaStreamPerThread>>>(NO, neworder, log, snapshot, index);
        if (NO < NEWORDER_CNT && thID == 0)
        {
            unsigned int raw = neworder->raw[NO];
            unsigned int war = neworder->war[NO];
            unsigned int waw = neworder->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                neworder->COMMIT_AND_ABORT[NO] = 1;
            }
        }

        __device__ void _swap_unsigned_int_up_down_id(unsigned int *f1_up,
                                              unsigned int *f2_up,
                                              unsigned int *f1_down,
                                              unsigned int *f2_down,
                                              unsigned int *ID1,
                                              unsigned int *ID2)
{ // sort_by_key 的双调排序实现, 交换排序元素的同时交换对应 ID
    unsigned int tmp_up = *f1_up;
    unsigned int tmp_down = *f1_down;
    unsigned int tmpID = *ID1;
    *f1_up = *f2_up;
    *f2_up = tmp_up;
    *f1_down = *f2_down;
    *f2_down = tmp_down;
    *ID1 = *ID2;
    *ID2 = tmpID;
}

__global__ void _bitonic_sort_unsigned_int_up_down_id(unsigned int *d_arr_up,
                                                      unsigned int *d_arr_down,
                                                      unsigned int stride,
                                                      unsigned int inner_stride,
                                                      unsigned int *d_TID)
{
    unsigned int flipper = inner_stride >> 1;
    unsigned int tid = blockIdx.x * blockDim.x + threadIdx.x;
    unsigned int tid_other = tid ^ flipper;

    if (tid < tid_other)
    {
        // 操纵左侧的半部分
        if ((tid & stride) == 0)
        {
            // 此处将留升序
            if ((d_arr_up[tid] > d_arr_up[tid_other]) || (d_arr_up[tid] == d_arr_up[tid_other] && d_arr_down[tid] > d_arr_down[tid_other]))
            {
                _swap_unsigned_int_up_down_id(&d_arr_up[tid], &d_arr_up[tid_other], &d_arr_down[tid], &d_arr_down[tid_other], &d_TID[tid], &d_TID[tid_other]);
            }
        }
        else
        {
            // 此处将留降序
            if ((d_arr_up[tid] < d_arr_up[tid_other]) || ((d_arr_up[tid] == d_arr_up[tid_other] && d_arr_down[tid] < d_arr_down[tid_other])))
            {
                _swap_unsigned_int_up_down_id(&d_arr_up[tid], &d_arr_up[tid_other], &d_arr_down[tid], &d_arr_down[tid_other], &d_TID[tid], &d_TID[tid_other]);
            }
        }
    }
}

void _sort_unsigned_int_up_down_id(unsigned int *arr_up,
                                   unsigned int *arr_down,
                                   unsigned int *TID,
                                   unsigned int len)
{

    // 首先检查长度是否为 2 的幂
    unsigned int twoUpper = 1;
    for (; twoUpper < len; twoUpper <<= 1)
    {
        if (twoUpper == len)
        {
            break;
        }
    }
    // 如果是 host 指针，返回
    unsigned int *d_input_arr_up;
    unsigned int *d_input_arr_down;
    unsigned int *d_input_TID;
    unsigned int input_arr_len;
    if (twoUpper == len)
    {
        d_input_arr_up = arr_up;
        d_input_arr_down = arr_down;
        d_input_TID = TID;
        input_arr_len = len;
    }
    else
    {
        // 需要 padding
        input_arr_len = twoUpper;
        cudaMalloc(&d_input_arr_up, sizeof(unsigned int) * input_arr_len);
        cudaMalloc(&d_input_arr_down, sizeof(unsigned int) * input_arr_len);
        cudaMalloc(&d_input_TID, sizeof(unsigned int) * input_arr_len);
        // 然后初始化
        cudaMemcpy(d_input_arr_up, arr_up, sizeof(unsigned int) * len, cudaMemcpyDeviceToDevice);
        cudaMemcpy(d_input_arr_down, arr_down, sizeof(unsigned int) * len, cudaMemcpyDeviceToDevice);
        cudaMemcpy(d_input_TID, TID, sizeof(unsigned int) * len, cudaMemcpyDeviceToDevice);
        cudaMemset(d_input_arr_up + len, (unsigned int)0xffffffff, sizeof(unsigned int) * (input_arr_len - len));
        cudaMemset(d_input_arr_down + len, (unsigned int)0xffffffff, sizeof(unsigned int) * (input_arr_len - len));
        cudaMemset(d_input_TID + len, (unsigned int)0xffffffff, sizeof(unsigned int) * (input_arr_len - len));
    }
    dim3 grid_dim((input_arr_len / 512 == 0) ? 1 : input_arr_len / 512);
    dim3 block_dim((input_arr_len / 512 == 0) ? input_arr_len : 512);
    // 排序过程(重点)
    for (unsigned int stride = 2; stride <= input_arr_len; stride <<= 1)
    {
        for (unsigned int inner_stride = stride; inner_stride >= 2; inner_stride >>= 1)
        {
            _bitonic_sort_unsigned_int_up_down_id<<<grid_dim, block_dim>>>(d_input_arr_up, d_input_arr_down, stride, inner_stride, d_input_TID);
        }
    }
    cudaDeviceSynchronize();
    // 如果 padding 过，则此处还原
    if (twoUpper != len)
    {
        cudaMemcpy(arr_up, d_input_arr_up, sizeof(unsigned int) * len, cudaMemcpyDeviceToDevice);
        cudaMemcpy(arr_down, d_input_arr_down, sizeof(unsigned int) * len, cudaMemcpyDeviceToDevice);
        cudaMemcpy(TID, d_input_TID, sizeof(unsigned int) * len, cudaMemcpyDeviceToDevice);
        cudaFree(d_input_arr_up);
        cudaFree(d_input_arr_down);
        cudaFree(d_input_TID);
    }
}

void _SORT_REGISTER(LOG *log)
{
    cudaMemcpy(log->LOG_LOC_UP, log->LOG_LOC_N_UP, sizeof(unsigned int) * NEWORDER_CNT * NEWORDER_OP_CNT, cudaMemcpyDeviceToDevice);
    cudaMemcpy(log->LOG_LOC_UP + NEWORDER_CNT * NEWORDER_OP_CNT, log->LOG_LOC_P_UP, sizeof(unsigned int) * PAYMENT_CNT * PAYMENT_OP_CNT, cudaMemcpyDeviceToDevice);
    cudaMemcpy(log->LOG_LOC_DOWN, log->LOG_LOC_N_DOWN, sizeof(unsigned int) * NEWORDER_CNT * NEWORDER_OP_CNT, cudaMemcpyDeviceToDevice);
    cudaMemcpy(log->LOG_LOC_DOWN + NEWORDER_CNT * NEWORDER_OP_CNT, log->LOG_LOC_P_DOWN, sizeof(unsigned int) * PAYMENT_CNT * PAYMENT_OP_CNT, cudaMemcpyDeviceToDevice);
    cudaMemcpy(log->LOG_TID, log->LOG_TID_N, sizeof(unsigned int) * NEWORDER_CNT * NEWORDER_OP_CNT, cudaMemcpyDeviceToDevice);
    cudaMemcpy(log->LOG_TID + NEWORDER_CNT * NEWORDER_OP_CNT, log->LOG_TID_P, sizeof(unsigned int) * PAYMENT_CNT * PAYMENT_OP_CNT, cudaMemcpyDeviceToDevice);
    // _sort_unsigned_int_up_down_id(log->LOG_LOC_UP, log->LOG_LOC_DOWN, log->LOG_TID, OP_CNT);
    unsigned int count = 0;
    // for (int i = 0; i < OP_CNT; i++)
    // {
    //     // printf("log_tid = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", log->LOG_TID[i], log->LOG_LOC_UP[i], log->LOG_LOC_DOWN[i]);
    //     if (log->LOG_TID[i] == 0xffffffff || log->LOG_LOC_UP[i] == 0xffffffff || log->LOG_LOC_DOWN[i] == 0xffffffff)
    //     {
    //         count += 1;
    //     }
    // }
    // printf("success %d\n", OP_CNT - count);
    // printf("0xffffffff %d\n", count);

    count = 0;
    for (int i = 0; i < NEWORDER_CNT * NEWORDER_OP_CNT; i++)
    {
        // printf("log_tid = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", log->LOG_TID[i], log->LOG_LOC_UP[i], log->LOG_LOC_DOWN[i]);
        if (log->LOG_TID_N[i] == 0xffffffff || log->LOG_LOC_N_UP[i] == 0xffffffff || log->LOG_LOC_N_DOWN[i] == 0xffffffff)
        {
            count += 1;
        }
    }
    printf("n success = %d\n", NEWORDER_CNT * NEWORDER_OP_CNT - count);
    printf("n 0xffffffff = %d\n", count);

    count = 0;
    for (int i = 0; i < PAYMENT_CNT * PAYMENT_OP_CNT; i++)
    {
        // printf("log_tid = 0x%08x, log_loc_up = 0x%08x, log_loc_down = 0x%08x\n", log->LOG_TID[i], log->LOG_LOC_UP[i], log->LOG_LOC_DOWN[i]);
        if (log->LOG_TID_P[i] == 0xffffffff || log->LOG_LOC_P_UP[i] == 0xffffffff || log->LOG_LOC_P_DOWN[i] == 0xffffffff)
        {
            count += 1;
        }
    }
    printf("p success %d\n", PAYMENT_CNT * PAYMENT_OP_CNT - count);
    printf("p 0xffffffff %d\n", count);

    // _subsort(log);
}

__global__ void _FIND(unsigned int NO,
                      unsigned int OP,
                      unsigned int TID,
                      unsigned int query_cnt,
                      unsigned int log_up,
                      unsigned int log_down,
                      unsigned int *CONFLICT_MARK_LIST,
                      unsigned int *LOG_LOC_UP,
                      unsigned int *LOG_LOC_DOWN,
                      unsigned int *LOG_TID)
{
    unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
    unsigned int flag;
    unsigned int start = 0;
    unsigned int end = OP_CNT - 1;
    unsigned int length = OP_CNT;
    length = length / blockDim.x;
    while (length > 0)
    {
        unsigned int tmp = 0;
        unsigned int element = 0xffffffff;
        flag = 0;
        if (start + length * thID < OP_CNT)
        {
            element = LOG_LOC_UP[start + length * thID];
        }

        flag = element < log_up ? 1 : 0;
        for (size_t i = 0; i < blockDim.x; i++)
        {
            tmp += __shfl_sync(0xffffffff, flag, i);
        }

        start = start + (tmp - 1) * length < start ? start : start + (tmp - 1) * length;

        flag = element > log_up ? 1 : 0;
        for (size_t i = 0; i < blockDim.x; i++)
        {
            tmp += __shfl_sync(0xffffffff, flag, i);
        }

        end = start + (blockDim.x - tmp) * length > end ? end : start + (blockDim.x - tmp) * length;

        length = length / blockDim.x;
    }
    length = end - start + 1;

    // length = length / blockDim.x;
    // while (length > 0)
    // {
    //     unsigned int tmp = 0;
    //     unsigned int element = 0xffffffff;
    //     flag = 0;
    //     if (start + length * thID < OP_CNT)
    //     {
    //         element = LOG_LOC_DOWN[start + length * thID];
    //     }

    //     flag = element < log_down ? 1 : 0;
    //     for (size_t i = 0; i < blockDim.x; i++)
    //     {
    //         tmp += __shfl_sync(0xffffffff, flag, i);
    //     }

    //     start = start + (tmp - 1) * length < start ? start : start + (tmp - 1) * length;

    //     flag = element > log_down ? 1 : 0;
    //     for (size_t i = 0; i < blockDim.x; i++)
    //     {
    //         tmp += __shfl_sync(0xffffffff, flag, i);
    //     }

    //     end = start + (blockDim.x - tmp) * length > end ? end : start + (blockDim.x - tmp) * length;

    //     length = length / blockDim.x;
    // }

    flag = 0;
    while (start <= end)
    {
        unsigned int tmp = 0;
        unsigned int element = 0xffffffff;
        if (start + thID < OP_CNT)
        {
            if (log_up == LOG_LOC_UP[start + thID] && log_down == LOG_LOC_DOWN[start + thID])
            {
                element = LOG_TID[start + thID];
            }
        }
        element = element < TID ? 1 : 0;
        for (size_t i = 0; i < blockDim.x; i++)
        {
            tmp += __shfl_sync(0xffffffff, element, i);
        }
        if (tmp > 0)
        {
            flag = 1;
            break;
        }
        start += blockDim.x;
    }

    if (thID == 0)
    {
        // unsigned int index = NO * query_cnt + OP;
        atomicAdd(&CONFLICT_MARK_LIST[NO], flag);
        // printf("TID = %d, OP = %d, flag = %d\n", TID, OP, flag);
    }
}
// __global__ void _READ_CHECK(unsigned int NO,
//                             unsigned int OP,
//                             unsigned int TID,      // 前 12 位是 BATCH_ID, 后 20 位是 ID
//                             unsigned int TABLE_ID, // 表示第几个表，放在 LOC 第一位
//                             unsigned int query_cnt,
//                             unsigned int Loc, // Loc 表示当前访问的数据在第几行
//                             unsigned int *CONFLICT_MARK_LIST_RAW,
//                             unsigned int *LOG_LOC_UP, // LOG_Loc 记录 LOC 信息, 上 4 位 TABLE_ID, 28位 LOC
//                             unsigned int *LOG_LOC_DOWN,
//                             unsigned int *LOG_TID) // LOG_TID 记录 TID 信息, 32 位 TID, 前 12 位是 BATCH_ID, 后 20 位是 ID
// {
//     unsigned int log_up = (TABLE_ID << 24) + (Loc >> 8);
//     unsigned int log_down = (Loc << 24) + WRITE_TYPE;
//     _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamFireAndForget>>>(NO, OP, TID, query_cnt, log_up, log_down, CONFLICT_MARK_LIST_RAW, LOG_LOC_UP, LOG_LOC_DOWN, LOG_TID);
// }

// __global__ void _WRITE_CHECK(unsigned int NO,
//                              unsigned int OP,
//                              unsigned int TID,      // 前 12 位是 BATCH_ID, 后 20 位是 ID
//                              unsigned int TABLE_ID, // 表示第几个表，放在 LOC 第一位
//                              unsigned int query_cnt,
//                              unsigned int Loc, // Loc 表示当前访问的数据在第几行
//                              unsigned int *CONFLICT_MARK_LIST_WAR,
//                              unsigned int *CONFLICT_MARK_LIST_WAW,
//                              unsigned int *LOG_LOC_UP, // LOG_Loc 记录 LOC 信息, 上 4 位 TABLE_ID, 28位 LOC
//                              unsigned int *LOG_LOC_DOWN,
//                              unsigned int *LOG_TID) // LOG_TID 记录 TID 信息, 32 位 TID, 前 12 位是 BATCH_ID, 后 20 位是 ID
// {
//     unsigned int log_up = (TABLE_ID << 24) + (Loc >> 8);
//     unsigned int log_down = (Loc << 24) + READ_TYPE;
//     _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamFireAndForget>>>(NO, OP, TID, query_cnt, log_up, log_down, CONFLICT_MARK_LIST_WAR, LOG_LOC_UP, LOG_LOC_DOWN, LOG_TID);
//     log_down = (Loc << 24) + WRITE_TYPE;
//     _FIND<<<FIND_GRID, FIND_BLOCK, 0, cudaStreamFireAndForget>>>(NO, OP, TID, query_cnt, log_up, log_down, CONFLICT_MARK_LIST_WAW, LOG_LOC_UP, LOG_LOC_DOWN, LOG_TID);
// }

__global__ void _WRITE_BACK(unsigned int NO,             // NO 表示当前实例是这类事务实例的第 NO 个
                            unsigned int OP,             // OP 表示当前操作是本示例中的第 OP 个
                            unsigned int query_cnt,      // query_cnt表示当前事务操作数量
                            unsigned int column_size,    // column_size 表示当前访问的数据表快照有多少行
                            unsigned int Loc,            // Loc 表示当前访问的数据在第几行
                            unsigned int Columns,        // Columns 表示当前访问的数据在第几列, 详细描述见下面对 Column 的操作
                            unsigned int *set_local_set, // set_local_set 是 SET 中的 local_set, 以 SoA 的形式实现
                            unsigned int *table,         // table 是当前访问的数据表快照
                            unsigned int *index,         // index 是当前访问数据表快照的索引, 预留了接口但并未使用
                            LOG *log)
{
    unsigned int thID = threadIdx.x; // thID 表示当前线程的 threadIdx.x
    // unsigned int column = 1 << thID;     // column 表示对 1 移位计算, 移位数量为当前线程ID, 如线程ID为 4, 则此时 column 此时为 0b10000
    // column = (Columns & column) && thID; // column 此时表示 Columns 与 对 1 移位计算的与运算结果, 如果 column 此时为 1, 表示第4列是要访问的数据
    // 如 column 此时为 0, 表示第4列不是要访问的数据
    // unsigned int local_set_loc = (NO * query_cnt + OP) * 32 + thID; // "OP * query_cnt" 表示原有设计中 set 在第几行, 列存储格式, 不同实例的相同操作放在一起
    // "OP * query_cnt + NO" 表示原有设计中的 set
    // "(OP * query_cnt + NO) * 32" 表示 set_local_set 的位置
    unsigned int column = Loc * column_size + thID;                   // "Loc * column_size + column" 表示要访问的数据在表中的位置, 行存储格式
    table[column] = set_local_set[(NO * query_cnt + OP) * 32 + thID]; // 从数据表快照中读取数据, 并修改到本地写集
                                                                      // printf("index = %d, query_cnt = %d, column_size = %d, Loc = %d, Columns = %d\n", NO * query_cnt + OP, query_cnt, column_size, Loc, Columns);
}


// __device__ void __RAWCHECK(unsigned int NO,
//                            unsigned int log_loc_up,
//                            unsigned int log_loc_down,
//                            unsigned int *CONFLICT_MARK,
//                            unsigned int *LOG_LOC_UP,
//                            unsigned int *LOG_LOC_DOWN,
//                            unsigned int *LOG_TID)
// {
//     atomicAdd(&CONFLICT_MARK[NO], 1);
// }
// __device__ void __WARCHECK(unsigned int NO,
//                            unsigned int log_loc_up,
//                            unsigned int log_loc_down,
//                            unsigned int *CONFLICT_MARK,
//                            unsigned int *LOG_LOC_UP,
//                            unsigned int *LOG_LOC_DOWN,
//                            unsigned int *LOG_TID)
// {
//     atomicAdd(&CONFLICT_MARK[NO], 1);
// }
// __device__ void __WAWCHECK(unsigned int NO,
//                            unsigned int log_loc_up,
//                            unsigned int log_loc_down,
//                            unsigned int *CONFLICT_MARK,
//                            unsigned int *LOG_LOC_UP,
//                            unsigned int *LOG_LOC_DOWN,
//                            unsigned int *LOG_TID)
// {
//     atomicAdd(&CONFLICT_MARK[NO], 1);
// }

 __global__ void op_wb_1(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update warehouse
        if (NO < PAYMENT_CNT)
        {
            unsigned int raw = payment->raw[NO];
            unsigned int war = payment->war[NO];
            unsigned int waw = payment->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = payment->set_Loc[NO * NEWORDER_OP_CNT + 1];
                _WRITE_BACK<<<1, WAREHOUSE_COLUMN, 0, cudaStreamPerThread>>>(NO, 1, PAYMENT_OP_CNT, WAREHOUSE_COLUMN, Loc, PAYMENT_COLUMN_1, payment->set_local_set, snapshot->warehouse_snapshot, index->index, log);
                payment->COMMIT_AND_ABORT[NO] = 1;
            }
        }
    }

    __global__ void op_wb_3(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update district
        if (NO < PAYMENT_CNT)
        {
            unsigned int raw = payment->raw[NO];
            unsigned int war = payment->war[NO];
            unsigned int waw = payment->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = payment->set_Loc[NO * NEWORDER_OP_CNT + 3];
                _WRITE_BACK<<<1, DISTRICT_COLUMN, 0, cudaStreamPerThread>>>(NO, 3, PAYMENT_OP_CNT, DISTRICT_COLUMN, Loc, PAYMENT_COLUMN_3, payment->set_local_set, snapshot->district_snapshot, index->index, log);
            }
        }
    }

    __global__ void op_wb_5(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update customer
        if (NO < PAYMENT_CNT)
        {
            unsigned int raw = payment->raw[NO];
            unsigned int war = payment->war[NO];
            unsigned int waw = payment->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = payment->set_Loc[NO * NEWORDER_OP_CNT + 5];
                _WRITE_BACK<<<1, CUSTOMER_COLUMN, 0, cudaStreamPerThread>>>(NO, 5, PAYMENT_OP_CNT, CUSTOMER_COLUMN, Loc, PAYMENT_COLUMN_5, payment->set_local_set, snapshot->customer_snapshot, index->index, log);
            }
        }
    }

    __global__ void op_wb_6(unsigned int NO,
                            PAYMENT_SET *payment,
                            LOG *log,
                            SNAPSHOT *snapshot,
                            INDEX *index)
    { // update history
        if (NO < PAYMENT_CNT)
        {
            unsigned int raw = payment->raw[NO];
            unsigned int war = payment->war[NO];
            unsigned int waw = payment->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                unsigned int Loc = payment->set_Loc[NO * NEWORDER_OP_CNT + 6];
                _WRITE_BACK<<<1, HISTORY_COLUMN, 0, cudaStreamPerThread>>>(NO, 6, PAYMENT_OP_CNT, HISTORY_COLUMN, Loc, PAYMENT_COLUMN_6, payment->set_local_set, snapshot->history_snapshot, index->index, log);
            }
        }
    }

    __global__ void write_back_op(unsigned int NO,
                                  PAYMENT_SET *payment,
                                  LOG *log,
                                  SNAPSHOT *snapshot,
                                  INDEX *index)
    {
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (thID == 0)
            op_wb_1<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 0)
            op_wb_3<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 0)
            op_wb_5<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 0)
            op_wb_6<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
    }
    // write_back_op<<<PAYMENT_WB_TYPE_CNT, 1, 0,cudaStreamPerThread  >>>(NO, payment, log, snapshot, index);
        unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
        if (thID == 0)
            op_wb_1<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 0)
            op_wb_3<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 0)
            op_wb_5<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (thID == 0)
            op_wb_6<<<1, 1, 0, cudaStreamPerThread>>>(NO, payment, log, snapshot, index);
        if (NO < NEWORDER_CNT && thID == 0)
        {
            unsigned int raw = payment->raw[NO];
            unsigned int war = payment->war[NO];
            unsigned int waw = payment->waw[NO];
            if ((waw == 0) && (raw == 0 || war == 0))
            {
                payment->COMMIT_AND_ABORT[NO] = 1;
            }
        }

        __global__ void KERNEL_CHECK(NEWORDER_SET *neworder,
                             PAYMENT_SET *payment,
                             LOG *log,
                             SNAPSHOT *snapshot,
                             INDEX *index)
{
    unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
    // if (thID == 0)
    // {
    //     // printf("KERNEL_EXECUTE threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
    //     dim3 block = (NEWORDER_CNT / BLOCK_SIZE == 0) ? NEWORDER_CNT : BLOCK_SIZE;
    //     dim3 grid = (NEWORDER_CNT / BLOCK_SIZE == 0) ? 1 : (NEWORDER_CNT / BLOCK_SIZE) + 1;
    //     NEWORDERQUERY::check<<<grid, block, 0, cudaStreamFireAndForget>>>(neworder, log, snapshot, index);
    // }
    // if (thID == 1)
    // {
    //     // printf("KERNEL_EXECUTE threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
    //     dim3 block = (PAYMENT_CNT / BLOCK_SIZE == 0) ? PAYMENT_CNT : BLOCK_SIZE;
    //     dim3 grid = (PAYMENT_CNT / BLOCK_SIZE == 0) ? 1 : (PAYMENT_CNT / BLOCK_SIZE) + 1;
    //     PAYMENTQUERY::check<<<grid, block, 0, cudaStreamFireAndForget>>>(payment, log, snapshot, index);
    // }
    // // printf("check\n");
    if (thID < NEWORDER_CNT)
    {
        dim3 nblock = 1;
        dim3 ngrid = 1;
        NEWORDERQUERY::check<<<NEWORDER_TYPE_CNT, nblock, 0, cudaStreamPerThread>>>(thID, neworder, log, snapshot, index);
    }
    else if (thID < BATCH_SIZE)
    {
        dim3 pblock = 1;
        dim3 pgrid = 1;
        PAYMENTQUERY::check<<<PAYMENT_TYPE_CNT, pblock, 0, cudaStreamPerThread>>>(thID - NEWORDER_CNT, payment, log, snapshot, index);
    }
}

__global__ void KERNEL_WRITEBACK(NEWORDER_SET *neworder,
                                 PAYMENT_SET *payment,
                                 LOG *log,
                                 SNAPSHOT *snapshot,
                                 INDEX *index)
{
    unsigned int thID = threadIdx.x + blockDim.x * blockIdx.x;
    // if (thID == 0)
    // {
    //     // printf("KERNEL_EXECUTE threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
    //     dim3 block = (NEWORDER_CNT / BLOCK_SIZE == 0) ? NEWORDER_CNT : BLOCK_SIZE;
    //     dim3 grid = (NEWORDER_CNT / BLOCK_SIZE == 0) ? 1 : (NEWORDER_CNT / BLOCK_SIZE) + 1;
    //     NEWORDERQUERY::write_back<<<grid, block, 0, cudaStreamFireAndForget>>>(neworder, log, snapshot, index);
    // }
    // if (thID == 1)
    // {
    //     // printf("KERNEL_EXECUTE threadIdx.x = %d, blockDim.x = %d, blockIdx.x = %d, gridDim.x = %d\n", threadIdx.x, blockDim.x, blockIdx.x, gridDim.x);
    //     dim3 block = (PAYMENT_CNT / BLOCK_SIZE == 0) ? PAYMENT_CNT : BLOCK_SIZE;
    //     dim3 grid = (PAYMENT_CNT / BLOCK_SIZE == 0) ? 1 : (PAYMENT_CNT / BLOCK_SIZE) + 1;
    //     PAYMENTQUERY::write_back<<<grid, block, 0, cudaStreamFireAndForget>>>(payment, log, snapshot, index);
    // }
    // // printf("check\n");
    if (thID < NEWORDER_CNT)
    {
        dim3 nblock = 1;
        dim3 ngrid = 1;
        NEWORDERQUERY::write_back<<<NEWORDER_WB_TYPE_CNT, nblock, 0, cudaStreamPerThread>>>(thID, neworder, log, snapshot, index);
    }
    else if (thID < BATCH_SIZE)
    {
        dim3 pblock = 1;
        dim3 pgrid = 1;
        PAYMENTQUERY::write_back<<<PAYMENT_WB_TYPE_CNT, pblock, 0, cudaStreamPerThread>>>(thID - NEWORDER_CNT, payment, log, snapshot, index);
    }
}


// void make_new(unsigned int BATCH_ID, Query *query)
// {
//     query->clear_QUERY();
//     long long start_t = current_time();
//     std::vector<std::thread> threads;
//     for (unsigned int i = 0; i < CPU_THREAD_SIZE; i++)
//     {
//         threads.push_back(std::thread(&Query::random_query, query, BATCH_ID));
//     }
//     for (unsigned int i = 0; i < CPU_THREAD_SIZE; i++)
//     {
//         threads[i].join();
//     }
//     neworder_ID = 0;
//     payment_ID = 0;
//     long long end_t = current_time();
//     float time = duration(start_t, end_t);
//     if (BATCH_ID == 0)
//     {
//         query->print();
//     }
//     std::cout << "Initiallization of queries costs [" << std::setprecision(2) << time << "s].\n\n";
//     while (bool_make)
//     {
//         cv_end_execute.wait(lock_end);
//     }
//     query->copy_to_device();
//     bool_execute = false;
//     bool_make = true;
//     cv_start_execute.notify_all();
// }
// void execute_tp_on_gpu(Database *database, Query *query)
// {
//     while (bool_execute)
//     {
//         cv_start_execute.wait(lock_start);
//     }
//     // ...
//     bool_execute = true;
//     bool_make = false;
//     cv_end_execute.notify_all();
// }
// void execute_tp_on_cpu(Database *database, Query *query)
// {
// }